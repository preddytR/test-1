<template>
  <div id="app">
    <img src="./assets/logo.png">
    <h1>{{ msg }}</h1>
    <span>Enter a polynomial function to solve:</span>
    <input name="poly" v-model="stringFunction" type="text" placeholder="e.g 4x^2+2x+3">
    <button name="solve" @click="solvePoly()">Solve</button>
    <h2>The Algorithm</h2>
    <ol>
      <li>First check if it has a trivial solution</li>
      <li>Find solutions to the given function's derivative</li>
      <li>If the function's derivative does not fall in to one of 3 base cases, keep differentiating the function until such a base case is found</li>

      <li>The 3 base cases are as follows</li>
      <li>A linear equation of form ax+b</li>
      <li>A quadratic equation of form ax^2+bx+c</li>
      <li>A two termed equation of the form ax^b+cx^d</li>

      <li>Once such a base case is reached, the solutions of that function are
          arranged as the critical points of the integral of that function.
          In this case integral refers to a function 'f' such that the derivative
          of f equals some function 'g' that we have solutions for</li>

      <li>With the function 'f' that has critical points as the solutions of 'g',
          each critical point is evaluated with 'f' and added to a list. Let 'c_n' be some critical point</li>
      <li>For each pair of adjacent critical points, if the evaluated values lie on opposite sides of the x-axis then it is added to a list of intervals</li>
      <li>The critical points at the start and end of this list may have solutions
          that lie outside this interval. To check if this is the case, the two points have their nature checked.
          If the nature of some point is negative and above the x-axis, or positive
          and below the x-axis, then there must exist a solution somewhere outside the list of critical points</li>
      <li>A guess point is generated by setting it an increasing amount of distance away from the critical point until they lie on opposite sides of the x-axis</li>
      <li>For this implementation of the algorithm it is created by starting from 1 and then doubling that until a satisfactory point is found</li>
      <li>This guess point and critical point can then also be added to the list of intervals</li>

      <li>Each pair of intervals is guarenteed to contain exactly one solution to the function</li>
      <li>The solution is found using an implementation of binary search where the interval's range is halved continually until it meets a satisfactory error margin</li>
      <li>The error margin used in this version simply checks that the next iteration produces a different interval. As the interval points are stored as 64bit floats,
        eventually the midpoint of two interval points will equal one of the interval points</li>

      <li>These solutions can then be used as critical points for the integral of this function. This recursive algorithm will then eventually find the solutions to
        the original function provided</li>
    </ol>
    <h2>Optimisations</h2>
    <ul>
      <li></li>
    </ul>
  </div>
</template>

<script>
export default {
  name: 'app',
  data () {
    return {
      stringFunction: "",
      msg: 'Solve any integer coeffients, integer power, single variable polynomial functions here'
    }
  },
  methods: {
    solvePoly: function(){
      return null
    }
  }
}
</script>

<style lang="scss">
#app {
  font-family: 'Avenir', Helvetica, Arial, sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  text-align: center;
  color: #2c3e50;
  margin-top: 60px;
}

h1, h2 {
  font-weight: normal;
}

ul {
  list-style-type: none;
  padding: 0;
}

ul li {
  display: inline-block;
  margin: 0 10px;
}
ol li{
  text-align: left;
}

a {
  color: #42b983;
}
</style>
